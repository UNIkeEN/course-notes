### 问题求解与实践 图文作业

UNIkeEN

#### 问题一

> 提出问题：图形学渲染中的某类常见操作可以简化为已知$n$​个矩形，这些矩形的边都平行于坐标轴，1）求出这些矩形的交集；2）求出这些矩形能够覆盖的面积

可以使用 **基于算法的系统** 解决

需要的前提条件：

1. **问题的明确性**:
   - 所有矩形的具体坐标和尺寸都已给出。
   - 矩形的边平行于坐标轴，这一条件明确简化了计算方法。
2. **问题的可计算性**:
   - 这个问题是可计算的，因为我们可以为每个矩形定义一个确定的坐标范围，并使用算法来计算它们的交集和并集。
3. **已知的求解方法**:
   - 我们需要知道或能够设计出计算矩形交集和覆盖面积的算法。对于这个问题，可以考虑使用扫描线算法来解决，算法存在有穷长度的描述，而且描述不“过于长”，可在合理时间内写完。
4. **计算复杂性**:
   - 可以通过扫描线算法，保证时间复杂度为$O(n)$，每个实例的求解都能在合理时间内完成

> 最终设计的算法如下：
>
> 首先求矩形的交集。对于任意边平行于坐标轴的矩形，可以用四个坐标表示其位置和大小：左上角的$x_{begin}$和$y_{begin}$，右上角的$x_{end}$，左下角的$y_{end}$。
>
> 易知交集如果存在，也是矩形，其坐标设为$(X_{begin}, Y_{begin}, X_{end}, Y_{end})$。取一个矩形作为交集的初始值。
>
> 依次遍历余下的每一个矩形，如果某矩形与当前交集不相交，即
> $$
> (x_{begin}\geq X_{end})\vee(x_{end}\leq X_{begin})\vee(y_{begin}\leq Y_{end})\vee(y_{end}\geq Y_{begin})
> $$
> 为真，程序终止，交集为空。
>
>  如果矩形与当前交集相交，则计算新的交集。条件如下：
> $$
> X_{begin}\leftarrow \texttt{max}(X_{begin}, x_{begin})\\
>                 X_{end}\leftarrow \texttt{min}(X_{end}, x_{end})\\
>                 Y_{begin}\leftarrow \texttt{min}(Y_{begin}, y_{begin})\\
>                 Y_{end}\leftarrow \texttt{max}(Y_{end}, y_{end})
> $$
> 遍历结束，则存在交集，交集为$(X_{begin}, Y_{begin}, X_{end}, Y_{end})$所代表的矩形。
>
> 对每个矩形的判断过程均为$O(1)$，整体时间复杂度为$O(n)$。
>
> 下求矩形能够覆盖的面积，同上一题，用$(x_{begin}, y_{begin}, x_{end}, y_{end})$​表示矩形。
>
> 将各个矩形按$x_{begin}$​进行排序，扫描线从左往右开始扫描，记录当前段开始的$x$​坐标和当前段存在矩形的$y$​方向坐标，遇到竖直边时计算当前部分有效面积并更新状态，数据结构可以使用最小化堆。
>



#### 问题二

使用万能头文件的弊端： 

* 编译速度慢：因为包含了大量不必要的头文件，编译器需要处理更多的代码，这会增加编译时间。 
* 内存占用高：如果头文件中包含了大量的静态数据或全局变量，使用万能头文件引入不必要的库会增加程序的内存使用。
* 缺乏模块化与可读性下降：其他开发者阅读代码时，可能不清楚哪些头文件实际上是必需的。如果产生命名冲突等情况，可能难以发现问题。
* 万能头文件可能不是C++标准的一部分，这会影响代码的移植性，部分编译器可能不支持。

##### 编译速度慢的验证

其中，编译速度慢是主要的弊端，可以通过`time`指令来判断代码的编译时间。

编写`test_1.cpp`如下，其未使用万能头文件：

```cpp
#include <iostream>
int main() {
    std::cout << "Hello world!" << std::endl;
    return 0;
}
```

编写`test_2.cpp`如下，其使用万能头文件，其余代码与之前相同：

```cpp
#include <bits/stdc++.h>
int main() {
    std::cout << "Hello world!" << std::endl;
    return 0;
}
```

使用如下时间检测编译时间：

```bash
time g++ test_1.cpp -o without
time g++ test_2.cpp -o with
```

结果如下：

```bash
(base) unikeen@ubuntu:~/Code/test$ time g++ test_1.cpp -o without

real    0m0.409s
user    0m0.206s
sys     0m0.064s

(base) unikeen@ubuntu:~/Code/test$ time g++ test_2.cpp -o with

real    0m0.846s
user    0m0.748s
sys     0m0.078s
```

可以看到**使用万能头文件所需的编译时间显著高于未使用时**。编译器在每次编译转换单元时都实际地读取并解析每个包含的头文件(包括递归包含的头文件)

##### 内存占用高的验证

可以使用`valgrind`工具进行分析，首先对编译过程进行分析，指令如下：

```bash
valgrind --tool=massif g++ test_1.cpp -o without
valgrind --tool=massif g++ test_2.cpp -o with
```

查看输出文件（过长此处省略展示），**在本例中，无论是使用还是不使用万能头文件，编译过程中的堆内存使用情况几乎相同，这可能与编译器的优化相关**。再对运行过程进行分析，指令如下：

```bash
valgrind --tool=massif ./without
valgrind --tool=massif ./with
```

查看输出结果，两者内存占用完全相同。



